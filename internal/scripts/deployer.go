// Copyright (c) 2025 Thorium

package scripts

import (
	"fmt"
	"io"
	"os"
	"path/filepath"
	"strings"

	"thorium-cli/internal/config"
)

// DeployScripts copies all script files from mods to TrinityCore source and generates CMakeLists.txt
func DeployScripts(cfg *config.Config, mods []string) error {
	// Check if TrinityCore scripts path is configured
	if cfg.TrinityCore.ScriptsPath == "" {
		fmt.Println("  TrinityCore scripts path not configured, skipping script deployment")
		return nil
	}

	// Ensure Custom scripts directory exists
	if err := os.MkdirAll(cfg.TrinityCore.ScriptsPath, 0755); err != nil {
		return fmt.Errorf("create scripts directory: %w", err)
	}

	// Collect all scripts from mods
	var scriptFiles []ScriptFile
	for _, mod := range mods {
		modScripts := filepath.Join(cfg.GetModsPath(), mod, "scripts")
		if _, err := os.Stat(modScripts); os.IsNotExist(err) {
			continue // Skip mods without scripts
		}

		files, err := collectScriptFiles(modScripts, mod)
		if err != nil {
			return fmt.Errorf("collect scripts from %s: %w", mod, err)
		}
		scriptFiles = append(scriptFiles, files...)
	}

	if len(scriptFiles) == 0 {
		fmt.Println("  No scripts found in mods")
		return nil
	}

	// Copy scripts to TrinityCore
	for _, script := range scriptFiles {
		destPath := filepath.Join(cfg.TrinityCore.ScriptsPath, script.FileName)
		if err := copyFile(script.SourcePath, destPath); err != nil {
			return fmt.Errorf("copy %s: %w", script.FileName, err)
		}
	}

	fmt.Printf("  Deployed %d script file(s) to TrinityCore\n", len(scriptFiles))

	// Generate CMakeLists.txt
	if err := generateCMakeLists(cfg.TrinityCore.ScriptsPath, scriptFiles); err != nil {
		return fmt.Errorf("generate CMakeLists.txt: %w", err)
	}

	fmt.Println("  Generated CMakeLists.txt")

	// Generate loader script
	if err := generateLoaderScript(cfg.TrinityCore.ScriptsPath, scriptFiles); err != nil {
		return fmt.Errorf("generate loader script: %w", err)
	}

	fmt.Println("  Generated custom_scripts_loader.cpp")

	return nil
}

// ScriptFile represents a script file with metadata
type ScriptFile struct {
	ModName    string
	FileName   string
	SourcePath string
	AddSCFunc  string // Function name like AddSC_spell_fire_blast
}

// collectScriptFiles finds all .cpp files in a directory
func collectScriptFiles(dir, modName string) ([]ScriptFile, error) {
	var files []ScriptFile

	entries, err := os.ReadDir(dir)
	if err != nil {
		return nil, err
	}

	for _, entry := range entries {
		if entry.IsDir() || !strings.HasSuffix(entry.Name(), ".cpp") {
			continue
		}

		// Extract AddSC function name from file
		sourcePath := filepath.Join(dir, entry.Name())
		addSCFunc, err := extractAddSCFunc(sourcePath)
		if err != nil || addSCFunc == "" {
			// Skip files without AddSC function
			continue
		}

		files = append(files, ScriptFile{
			ModName:    modName,
			FileName:   entry.Name(),
			SourcePath: sourcePath,
			AddSCFunc:  addSCFunc,
		})
	}

	return files, nil
}

// extractAddSCFunc extracts the AddSC_* function name from a script file
func extractAddSCFunc(filePath string) (string, error) {
	data, err := os.ReadFile(filePath)
	if err != nil {
		return "", err
	}

	content := string(data)
	
	// Look for pattern: void AddSC_something()
	lines := strings.Split(content, "\n")
	for _, line := range lines {
		line = strings.TrimSpace(line)
		if strings.HasPrefix(line, "void AddSC_") {
			// Extract function name
			if idx := strings.Index(line, "("); idx != -1 {
				funcDef := line[:idx]
				funcName := strings.TrimPrefix(funcDef, "void ")
				return strings.TrimSpace(funcName), nil
			}
		}
	}

	return "", fmt.Errorf("no AddSC function found in %s", filePath)
}

// copyFile copies a file from src to dst
func copyFile(src, dst string) error {
	sourceFile, err := os.Open(src)
	if err != nil {
		return err
	}
	defer sourceFile.Close()

	destFile, err := os.Create(dst)
	if err != nil {
		return err
	}
	defer destFile.Close()

	if _, err := io.Copy(destFile, sourceFile); err != nil {
		return err
	}

	return destFile.Sync()
}

// generateCMakeLists creates CMakeLists.txt for custom scripts
func generateCMakeLists(scriptsPath string, scripts []ScriptFile) error {
	var sources []string
	for _, script := range scripts {
		sources = append(sources, script.FileName)
	}

	content := fmt.Sprintf(`# Auto-generated by Thorium
# Do not edit manually

set(CUSTOM_SCRIPTS
  custom_scripts_loader.cpp
  %s
)

add_library(scripts-custom STATIC ${CUSTOM_SCRIPTS})

target_link_libraries(scripts-custom
  PUBLIC
    game-interface
)

# Set IDE source group
GroupSources(${CMAKE_CURRENT_SOURCE_DIR})
`, strings.Join(sources, "\n  "))

	cmakePath := filepath.Join(scriptsPath, "CMakeLists.txt")
	return os.WriteFile(cmakePath, []byte(content), 0644)
}

// generateLoaderScript creates the loader that calls all AddSC functions
func generateLoaderScript(scriptsPath string, scripts []ScriptFile) error {
	var forwardDecls []string
	var calls []string

	for _, script := range scripts {
		forwardDecls = append(forwardDecls, fmt.Sprintf("void %s();", script.AddSCFunc))
		calls = append(calls, fmt.Sprintf("    %s(); // %s", script.AddSCFunc, script.ModName))
	}

	content := fmt.Sprintf(`// Auto-generated by Thorium
// Do not edit manually

#include "ScriptMgr.h"

// Forward declarations
%s

// This function is called by ScriptMgr to load all custom scripts
void AddCustomScripts()
{
%s
}
`, strings.Join(forwardDecls, "\n"), strings.Join(calls, "\n"))

	loaderPath := filepath.Join(scriptsPath, "custom_scripts_loader.cpp")
	return os.WriteFile(loaderPath, []byte(content), 0644)
}
