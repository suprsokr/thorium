// Copyright (c) 2025 Thorium
// Ported from TSWoW CustomPackets

package custompackets

import (
	"fmt"
	"os"
	"path/filepath"
	"time"
)

// LuaGeneratorOptions contains options for generating the Lua API file
type LuaGeneratorOptions struct {
	OutputPath    string // Full path to output file
	IncludeStub   bool   // Include stub implementations for testing without DLL
	ServerOpcode  uint16 // Base opcode for server->client (default: 0x102)
	ClientOpcode  uint16 // Base opcode for client->server (default: 0x51F)
}

// DefaultLuaGeneratorOptions returns default options
func DefaultLuaGeneratorOptions() LuaGeneratorOptions {
	return LuaGeneratorOptions{
		OutputPath:   "CustomPackets.lua",
		IncludeStub:  false,
		ServerOpcode: ServerToClientOpcode,
		ClientOpcode: ClientToServerOpcode,
	}
}

// GenerateLuaAPI generates the CustomPackets.lua file for WoW addons
func GenerateLuaAPI(opts LuaGeneratorOptions) error {
	if opts.ServerOpcode == 0 {
		opts.ServerOpcode = ServerToClientOpcode
	}
	if opts.ClientOpcode == 0 {
		opts.ClientOpcode = ClientToServerOpcode
	}

	content := generateLuaContent(opts)

	// Ensure directory exists
	dir := filepath.Dir(opts.OutputPath)
	if dir != "" && dir != "." {
		if err := os.MkdirAll(dir, 0755); err != nil {
			return fmt.Errorf("create directory: %w", err)
		}
	}

	if err := os.WriteFile(opts.OutputPath, []byte(content), 0644); err != nil {
		return fmt.Errorf("write file: %w", err)
	}

	return nil
}

func generateLuaContent(opts LuaGeneratorOptions) string {
	timestamp := time.Now().Format("2006-01-02 15:04:05")

	lua := fmt.Sprintf(`-- CustomPackets Lua API for WoW 3.3.5a
-- Generated by Thorium on %s
-- Place this file in Interface/AddOns/YourAddon/

--[[
    CustomPackets Protocol
    ======================
    
    This system allows sending and receiving custom packets between the WoW client
    and a modified server. Packets are fragmented automatically for large payloads.
    
    Header Format (6 bytes):
    - FragmentID (uint16): Current fragment index (0-based)
    - TotalFrags (uint16): Total number of fragments
    - Opcode (uint16): Custom packet opcode (your defined ID)
    
    Base Opcodes:
    - Server->Client: 0x%03X
    - Client->Server: 0x%03X
    
    Maximum fragment size: %d bytes
    Minimum fragment size: %d bytes
]]

-- ============================================================================
-- Constants
-- ============================================================================

CUSTOM_PACKET_HEADER_SIZE = %d
CUSTOM_PACKET_MAX_FRAGMENT_SIZE = %d
CUSTOM_PACKET_MIN_FRAGMENT_SIZE = %d
CUSTOM_PACKET_SERVER_OPCODE = 0x%03X
CUSTOM_PACKET_CLIENT_OPCODE = 0x%03X

-- ============================================================================
-- Packet Registry
-- ============================================================================

local packetHandlers = {}
local pendingFragments = {}

-- ============================================================================
-- Writer Class
-- ============================================================================

---@class CustomPacketWriter
---@field opcode number Custom packet opcode
---@field buffer table Byte buffer
local CustomPacketWriter = {}
CustomPacketWriter.__index = CustomPacketWriter

--- Create a new packet writer
---@param opcode number Custom packet opcode (0-65535)
---@param size number|nil Expected size (optional, for pre-allocation)
---@return CustomPacketWriter
function CreateCustomPacket(opcode, size)
    local self = setmetatable({}, CustomPacketWriter)
    self.opcode = opcode
    self.buffer = {}
    return self
end

--- Write an unsigned 8-bit integer
---@param value number Value (0-255)
---@return CustomPacketWriter
function CustomPacketWriter:WriteUInt8(value)
    table.insert(self.buffer, bit.band(value, 0xFF))
    return self
end

--- Write a signed 8-bit integer
---@param value number Value (-128 to 127)
---@return CustomPacketWriter
function CustomPacketWriter:WriteInt8(value)
    if value < 0 then value = value + 256 end
    return self:WriteUInt8(value)
end

--- Write an unsigned 16-bit integer (little-endian)
---@param value number Value (0-65535)
---@return CustomPacketWriter
function CustomPacketWriter:WriteUInt16(value)
    table.insert(self.buffer, bit.band(value, 0xFF))
    table.insert(self.buffer, bit.band(bit.rshift(value, 8), 0xFF))
    return self
end

--- Write a signed 16-bit integer (little-endian)
---@param value number Value (-32768 to 32767)
---@return CustomPacketWriter
function CustomPacketWriter:WriteInt16(value)
    if value < 0 then value = value + 65536 end
    return self:WriteUInt16(value)
end

--- Write an unsigned 32-bit integer (little-endian)
---@param value number Value (0-4294967295)
---@return CustomPacketWriter
function CustomPacketWriter:WriteUInt32(value)
    table.insert(self.buffer, bit.band(value, 0xFF))
    table.insert(self.buffer, bit.band(bit.rshift(value, 8), 0xFF))
    table.insert(self.buffer, bit.band(bit.rshift(value, 16), 0xFF))
    table.insert(self.buffer, bit.band(bit.rshift(value, 24), 0xFF))
    return self
end

--- Write a signed 32-bit integer (little-endian)
---@param value number Value (-2147483648 to 2147483647)
---@return CustomPacketWriter
function CustomPacketWriter:WriteInt32(value)
    if value < 0 then value = value + 4294967296 end
    return self:WriteUInt32(value)
end

--- Write an unsigned 64-bit integer (little-endian)
--- Note: Lua numbers have limited precision for large integers
---@param value number Value
---@return CustomPacketWriter
function CustomPacketWriter:WriteUInt64(value)
    -- Split into two 32-bit parts
    local low = value %% 4294967296
    local high = math.floor(value / 4294967296)
    self:WriteUInt32(low)
    self:WriteUInt32(high)
    return self
end

--- Write a signed 64-bit integer (little-endian)
---@param value number Value
---@return CustomPacketWriter
function CustomPacketWriter:WriteInt64(value)
    if value < 0 then
        -- Two's complement for negative values
        value = value + 18446744073709551616
    end
    return self:WriteUInt64(value)
end

--- Write a 32-bit float (little-endian)
---@param value number Float value
---@return CustomPacketWriter
function CustomPacketWriter:WriteFloat(value)
    -- IEEE 754 single precision
    local sign = 0
    if value < 0 then
        sign = 1
        value = -value
    end
    
    local mantissa, exponent = math.frexp(value)
    if value == 0 then
        mantissa = 0
        exponent = 0
    else
        mantissa = (mantissa * 2 - 1) * 8388608 -- 2^23
        exponent = exponent + 126
    end
    
    local bits = bit.bor(
        bit.lshift(sign, 31),
        bit.lshift(bit.band(exponent, 0xFF), 23),
        bit.band(mantissa, 0x7FFFFF)
    )
    
    return self:WriteUInt32(bits)
end

--- Write a 64-bit double (little-endian)
---@param value number Double value
---@return CustomPacketWriter
function CustomPacketWriter:WriteDouble(value)
    -- Simplified: use string.pack if available (Lua 5.3+), otherwise approximate
    -- For WoW's Lua 5.1, we need manual conversion
    local sign = 0
    if value < 0 then
        sign = 1
        value = -value
    end
    
    if value == 0 then
        self:WriteUInt32(0)
        self:WriteUInt32(0)
        return self
    end
    
    local mantissa, exponent = math.frexp(value)
    exponent = exponent + 1022
    mantissa = (mantissa * 2 - 1) * 4503599627370496 -- 2^52
    
    local low = mantissa %% 4294967296
    local high = bit.bor(
        bit.lshift(sign, 31),
        bit.lshift(bit.band(exponent, 0x7FF), 20),
        bit.band(math.floor(mantissa / 4294967296), 0xFFFFF)
    )
    
    self:WriteUInt32(low)
    self:WriteUInt32(high)
    return self
end

--- Write a null-terminated string
---@param value string String to write
---@return CustomPacketWriter
function CustomPacketWriter:WriteString(value)
    for i = 1, #value do
        table.insert(self.buffer, string.byte(value, i))
    end
    table.insert(self.buffer, 0) -- null terminator
    return self
end

--- Write a length-prefixed string (uint32 length + bytes, no null terminator)
---@param value string String to write
---@return CustomPacketWriter
function CustomPacketWriter:WriteLengthString(value)
    self:WriteUInt32(#value)
    for i = 1, #value do
        table.insert(self.buffer, string.byte(value, i))
    end
    return self
end

--- Write raw bytes
---@param bytes table Array of bytes
---@return CustomPacketWriter
function CustomPacketWriter:WriteBytes(bytes)
    for _, b in ipairs(bytes) do
        table.insert(self.buffer, bit.band(b, 0xFF))
    end
    return self
end

--- Get the current size of the packet
---@return number
function CustomPacketWriter:Size()
    return #self.buffer
end

--- Send the packet to the server
--- Note: This requires the CustomPackets DLL to be loaded
function CustomPacketWriter:Send()
    if not SendCustomPacket then
        error("CustomPackets DLL not loaded. Apply the custom-packets patch first.")
    end
    SendCustomPacket(self.opcode, self.buffer)
end

-- ============================================================================
-- Reader Class
-- ============================================================================

---@class CustomPacketReader
---@field opcode number Custom packet opcode
---@field buffer table Byte buffer
---@field position number Current read position
local CustomPacketReader = {}
CustomPacketReader.__index = CustomPacketReader

--- Create a reader from raw data (internal use)
---@param opcode number
---@param data table
---@return CustomPacketReader
local function CreateReader(opcode, data)
    local self = setmetatable({}, CustomPacketReader)
    self.opcode = opcode
    self.buffer = data
    self.position = 1
    return self
end

--- Get remaining bytes
---@return number
function CustomPacketReader:Remaining()
    return #self.buffer - self.position + 1
end

--- Read an unsigned 8-bit integer
---@param default number|nil Default value if read fails
---@return number
function CustomPacketReader:ReadUInt8(default)
    if self.position > #self.buffer then return default or 0 end
    local value = self.buffer[self.position]
    self.position = self.position + 1
    return value
end

--- Read a signed 8-bit integer
---@param default number|nil Default value if read fails
---@return number
function CustomPacketReader:ReadInt8(default)
    local value = self:ReadUInt8(default)
    if value >= 128 then value = value - 256 end
    return value
end

--- Read an unsigned 16-bit integer (little-endian)
---@param default number|nil Default value if read fails
---@return number
function CustomPacketReader:ReadUInt16(default)
    if self:Remaining() < 2 then return default or 0 end
    local low = self:ReadUInt8(0)
    local high = self:ReadUInt8(0)
    return low + high * 256
end

--- Read a signed 16-bit integer (little-endian)
---@param default number|nil Default value if read fails
---@return number
function CustomPacketReader:ReadInt16(default)
    local value = self:ReadUInt16(default)
    if value >= 32768 then value = value - 65536 end
    return value
end

--- Read an unsigned 32-bit integer (little-endian)
---@param default number|nil Default value if read fails
---@return number
function CustomPacketReader:ReadUInt32(default)
    if self:Remaining() < 4 then return default or 0 end
    local b1 = self:ReadUInt8(0)
    local b2 = self:ReadUInt8(0)
    local b3 = self:ReadUInt8(0)
    local b4 = self:ReadUInt8(0)
    return b1 + b2 * 256 + b3 * 65536 + b4 * 16777216
end

--- Read a signed 32-bit integer (little-endian)
---@param default number|nil Default value if read fails
---@return number
function CustomPacketReader:ReadInt32(default)
    local value = self:ReadUInt32(default)
    if value >= 2147483648 then value = value - 4294967296 end
    return value
end

--- Read an unsigned 64-bit integer (little-endian)
---@param default number|nil Default value if read fails
---@return number
function CustomPacketReader:ReadUInt64(default)
    if self:Remaining() < 8 then return default or 0 end
    local low = self:ReadUInt32(0)
    local high = self:ReadUInt32(0)
    return low + high * 4294967296
end

--- Read a signed 64-bit integer (little-endian)
---@param default number|nil Default value if read fails
---@return number
function CustomPacketReader:ReadInt64(default)
    local value = self:ReadUInt64(default)
    if value >= 9223372036854775808 then
        value = value - 18446744073709551616
    end
    return value
end

--- Read a 32-bit float (little-endian)
---@param default number|nil Default value if read fails
---@return number
function CustomPacketReader:ReadFloat(default)
    if self:Remaining() < 4 then return default or 0 end
    local bits = self:ReadUInt32(0)
    
    local sign = bit.band(bit.rshift(bits, 31), 1)
    local exponent = bit.band(bit.rshift(bits, 23), 0xFF)
    local mantissa = bit.band(bits, 0x7FFFFF)
    
    if exponent == 0 and mantissa == 0 then
        return 0
    end
    
    local value = math.ldexp(mantissa / 8388608 + 1, exponent - 127)
    if sign == 1 then value = -value end
    return value
end

--- Read a 64-bit double (little-endian)
---@param default number|nil Default value if read fails
---@return number
function CustomPacketReader:ReadDouble(default)
    if self:Remaining() < 8 then return default or 0 end
    local low = self:ReadUInt32(0)
    local high = self:ReadUInt32(0)
    
    local sign = bit.band(bit.rshift(high, 31), 1)
    local exponent = bit.band(bit.rshift(high, 20), 0x7FF)
    local mantissa = bit.band(high, 0xFFFFF) * 4294967296 + low
    
    if exponent == 0 and mantissa == 0 then
        return 0
    end
    
    local value = math.ldexp(mantissa / 4503599627370496 + 1, exponent - 1023)
    if sign == 1 then value = -value end
    return value
end

--- Read a null-terminated string
---@param default string|nil Default value if read fails
---@return string
function CustomPacketReader:ReadString(default)
    local chars = {}
    while self.position <= #self.buffer do
        local b = self:ReadUInt8(0)
        if b == 0 then break end
        table.insert(chars, string.char(b))
    end
    if #chars == 0 and default then return default end
    return table.concat(chars)
end

--- Read a length-prefixed string (uint32 length + bytes)
---@param default string|nil Default value if read fails
---@return string
function CustomPacketReader:ReadLengthString(default)
    local length = self:ReadUInt32(0xFFFFFFFF)
    if length == 0xFFFFFFFF then return default or "" end
    if length == 0 then return "" end
    if self:Remaining() < length then return default or "" end
    
    local chars = {}
    for i = 1, length do
        table.insert(chars, string.char(self:ReadUInt8(0)))
    end
    return table.concat(chars)
end

--- Read raw bytes
---@param count number Number of bytes to read
---@return table Array of bytes
function CustomPacketReader:ReadBytes(count)
    local bytes = {}
    for i = 1, count do
        if self.position > #self.buffer then break end
        table.insert(bytes, self:ReadUInt8(0))
    end
    return bytes
end

--- Skip bytes
---@param count number Number of bytes to skip
function CustomPacketReader:Skip(count)
    self.position = self.position + count
end

--- Reset read position to beginning
function CustomPacketReader:Reset()
    self.position = 1
end

-- ============================================================================
-- Packet Registration
-- ============================================================================

--- Register a handler for a custom packet opcode
---@param opcode number Custom packet opcode to listen for
---@param callback function Function called with (reader) when packet is received
function OnCustomPacket(opcode, callback)
    if type(opcode) ~= "number" then
        error("OnCustomPacket: opcode must be a number")
    end
    if type(callback) ~= "function" then
        error("OnCustomPacket: callback must be a function")
    end
    packetHandlers[opcode] = callback
end

--- Unregister a handler for a custom packet opcode
---@param opcode number Custom packet opcode to stop listening for
function OffCustomPacket(opcode)
    packetHandlers[opcode] = nil
end

-- ============================================================================
-- Internal: Packet Reception (called by DLL)
-- ============================================================================

--- Called by the DLL when a custom packet fragment is received
--- @param fragmentId number Current fragment index
--- @param totalFrags number Total number of fragments
--- @param opcode number Custom packet opcode
--- @param data table Raw byte data (excluding header)
function _CustomPacketReceive(fragmentId, totalFrags, opcode, data)
    -- Single fragment packet
    if totalFrags == 1 then
        local handler = packetHandlers[opcode]
        if handler then
            local reader = CreateReader(opcode, data)
            local success, err = pcall(handler, reader)
            if not success then
                print("|cFFFF0000CustomPackets Error:|r " .. tostring(err))
            end
        end
        return
    end
    
    -- Multi-fragment packet: accumulate
    local key = opcode
    if fragmentId == 0 then
        pendingFragments[key] = { fragments = {}, expected = totalFrags }
    end
    
    local pending = pendingFragments[key]
    if not pending then
        -- Missed first fragment
        return
    end
    
    pending.fragments[fragmentId + 1] = data
    
    -- Check if complete
    if #pending.fragments == pending.expected then
        -- Concatenate all fragments
        local fullData = {}
        for i = 1, pending.expected do
            for _, b in ipairs(pending.fragments[i]) do
                table.insert(fullData, b)
            end
        end
        
        pendingFragments[key] = nil
        
        local handler = packetHandlers[opcode]
        if handler then
            local reader = CreateReader(opcode, fullData)
            local success, err = pcall(handler, reader)
            if not success then
                print("|cFFFF0000CustomPackets Error:|r " .. tostring(err))
            end
        end
    end
end

-- ============================================================================
-- Initialization
-- ============================================================================

print("|cFF00FF00CustomPackets|r Lua API loaded (Thorium)")

`, timestamp,
		opts.ServerOpcode, opts.ClientOpcode,
		MaxFragmentSize, MinFragmentSize,
		HeaderSize(), MaxFragmentSize, MinFragmentSize,
		opts.ServerOpcode, opts.ClientOpcode)

	return lua
}

// GenerateLuaAPIToAddonDir generates the Lua API to a WoW addon directory
func GenerateLuaAPIToAddonDir(wowPath string, addonName string) (string, error) {
	if addonName == "" {
		addonName = "CustomPackets"
	}

	addonDir := filepath.Join(wowPath, "Interface", "AddOns", addonName)
	luaPath := filepath.Join(addonDir, "CustomPackets.lua")

	opts := DefaultLuaGeneratorOptions()
	opts.OutputPath = luaPath

	if err := GenerateLuaAPI(opts); err != nil {
		return "", err
	}

	// Also generate a simple TOC file if it doesn't exist
	tocPath := filepath.Join(addonDir, addonName+".toc")
	if _, err := os.Stat(tocPath); os.IsNotExist(err) {
		tocContent := fmt.Sprintf(`## Interface: 30300
## Title: %s
## Notes: Custom packet API for server communication
## Author: Thorium

CustomPackets.lua
`, addonName)
		if err := os.WriteFile(tocPath, []byte(tocContent), 0644); err != nil {
			return "", fmt.Errorf("write TOC: %w", err)
		}
	}

	return addonDir, nil
}
