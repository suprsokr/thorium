// Copyright (c) 2025 Thorium
// Ported from TSWoW CustomPackets

package custompackets

import (
	"fmt"
	"os"
	"path/filepath"
	"time"
)

// LuaGeneratorOptions contains options for generating the Lua API file
type LuaGeneratorOptions struct {
	OutputPath    string // Full path to output file
	IncludeStub   bool   // Include stub implementations for testing without DLL
	ServerOpcode  uint16 // Base opcode for server->client (default: 0x102)
	ClientOpcode  uint16 // Base opcode for client->server (default: 0x51F)
}

// DefaultLuaGeneratorOptions returns default options
func DefaultLuaGeneratorOptions() LuaGeneratorOptions {
	return LuaGeneratorOptions{
		OutputPath:   "CustomPackets.lua",
		IncludeStub:  false,
		ServerOpcode: ServerToClientOpcode,
		ClientOpcode: ClientToServerOpcode,
	}
}

// GenerateLuaAPI generates the CustomPackets.lua file for WoW addons
func GenerateLuaAPI(opts LuaGeneratorOptions) error {
	if opts.ServerOpcode == 0 {
		opts.ServerOpcode = ServerToClientOpcode
	}
	if opts.ClientOpcode == 0 {
		opts.ClientOpcode = ClientToServerOpcode
	}

	content := generateLuaContent(opts)

	// Ensure directory exists
	dir := filepath.Dir(opts.OutputPath)
	if dir != "" && dir != "." {
		if err := os.MkdirAll(dir, 0755); err != nil {
			return fmt.Errorf("create directory: %w", err)
		}
	}

	if err := os.WriteFile(opts.OutputPath, []byte(content), 0644); err != nil {
		return fmt.Errorf("write file: %w", err)
	}

	return nil
}

func generateLuaContent(opts LuaGeneratorOptions) string {
	timestamp := time.Now().Format("2006-01-02 15:04:05")

	lua := fmt.Sprintf(`-- CustomPackets Lua API for WoW 3.3.5a
-- Compatible with ClientExtensions.dll (based on TSWoW)
-- Generated by Thorium on %s

--[[
    CustomPackets Protocol
    ======================
    
    This system allows sending and receiving custom packets between the WoW client
    and server using ClientExtensions.dll.
    
    Base Opcodes (handled by DLL):
    - Server->Client: 0x%03X
    - Client->Server: 0x%03X
    
    Maximum fragment size: %d bytes
    Minimum fragment size: %d bytes
]]

-- Enum for _CLIENT_NETWORK opcodes
local LuaNetworkOpcode = {
    ["WRITE_SIZE"]          = 0,
    ["READ_SIZE"]           = 1,
    ["WRITE_UINT8"]         = 2,
    ["WRITE_INT8"]          = 3,
    ["WRITE_UINT16"]        = 4,
    ["WRITE_INT16"]         = 5,
    ["WRITE_UINT32"]        = 6,
    ["WRITE_INT32"]         = 7,
    ["WRITE_UINT64"]        = 8,
    ["WRITE_INT64"]         = 9,
    ["WRITE_FLOAT"]         = 10,
    ["WRITE_DOUBLE"]        = 11,
    ["WRITE_STRING"]        = 12,

    ["READ_UINT8"]          = 13,
    ["READ_INT8"]           = 14,
    ["READ_UINT16"]         = 15,
    ["READ_INT16"]         = 16,
    ["READ_UINT32"]         = 17,
    ["READ_INT32"]          = 18,
    ["READ_UINT64"]         = 19,
    ["READ_INT64"]          = 20,
    ["READ_FLOAT"]          = 21,
    ["READ_DOUBLE"]         = 22,
    ["READ_STRING"]         = 23,
    ["MAKE_CUSTOM_PACKET"]  = 24,
    ["SEND_CUSTOM_PACKET"]  = 25,
    ["RESET_CUSTOM_PACKET"] = 26,
}

}

--- Create a new custom packet writer
---@param opcode number Custom packet opcode (your defined ID)
---@param size number|nil Expected size (optional, for optimization)
---@return table Writer object with Write* and Send methods
function CreateCustomPacket(opcode, size)
    local writer = { id = _CLIENT_NETWORK(LuaNetworkOpcode.MAKE_CUSTOM_PACKET, opcode, size or 0) }

    function writer:WriteUInt8(value)
        _CLIENT_NETWORK(LuaNetworkOpcode.WRITE_UINT8, self.id, value)
        return self
    end

    function writer:WriteInt8(value)
        _CLIENT_NETWORK(LuaNetworkOpcode.WRITE_INT8, self.id, value)
        return self
    end

    function writer:WriteUInt16(value)
        _CLIENT_NETWORK(LuaNetworkOpcode.WRITE_UINT16, self.id, value)
        return self
    end

    function writer:WriteInt16(value)
        _CLIENT_NETWORK(LuaNetworkOpcode.WRITE_INT16, self.id, value)
        return self
    end

    function writer:WriteUInt32(value)
        _CLIENT_NETWORK(LuaNetworkOpcode.WRITE_UINT32, self.id, value)
        return self
    end

    function writer:WriteInt32(value)
        _CLIENT_NETWORK(LuaNetworkOpcode.WRITE_INT32, self.id, value)
        return self
    end
    
    function writer:WriteUInt64(value)
        _CLIENT_NETWORK(LuaNetworkOpcode.WRITE_UINT64, self.id, value)
        return self
    end

    function writer:WriteInt64(value)
        _CLIENT_NETWORK(LuaNetworkOpcode.WRITE_INT64, self.id, value)
        return self
    end

    function writer:WriteFloat(value)
        _CLIENT_NETWORK(LuaNetworkOpcode.WRITE_FLOAT, self.id, value)
        return self
    end

    function writer:WriteDouble(value)
        _CLIENT_NETWORK(LuaNetworkOpcode.WRITE_DOUBLE, self.id, value)
        return self
    end

    function writer:WriteString(value)
        _CLIENT_NETWORK(LuaNetworkOpcode.WRITE_STRING, self.id, value)
        return self
    end

    function writer:Size()
        return _CLIENT_NETWORK(LuaNetworkOpcode.WRITE_SIZE, self.id)
    end

    function writer:Send()
        _CLIENT_NETWORK(LuaNetworkOpcode.SEND_CUSTOM_PACKET, self.id)
        return self
    end

    return writer
end

--- Create a packet reader (internal use by DLL)
---@return table Reader object with Read* methods
function __ReadCustomPacket()
    local reader = {}

    function reader:ReadUInt8(default)
        return _CLIENT_NETWORK(LuaNetworkOpcode.READ_UINT8, default or 0)
    end

    function reader:ReadInt8(default)
        return _CLIENT_NETWORK(LuaNetworkOpcode.READ_INT8, default or 0)
    end

    function reader:ReadUInt16(default)
        return _CLIENT_NETWORK(LuaNetworkOpcode.READ_UINT16, default or 0)
    end

    function reader:ReadInt16(default)
        return _CLIENT_NETWORK(LuaNetworkOpcode.READ_INT16, default or 0)
    end

    function reader:ReadUInt32(default)
        return _CLIENT_NETWORK(LuaNetworkOpcode.READ_UINT32, default or 0)
    end

    function reader:ReadInt32(default)
        return _CLIENT_NETWORK(LuaNetworkOpcode.READ_INT32, default or 0)
    end
    
    function reader:ReadUInt64(default)
        return _CLIENT_NETWORK(LuaNetworkOpcode.READ_UINT64, default or 0)
    end

    function reader:ReadInt64(default)
        return _CLIENT_NETWORK(LuaNetworkOpcode.READ_INT64, default or 0)
    end

    function reader:ReadFloat(default)
        return _CLIENT_NETWORK(LuaNetworkOpcode.READ_FLOAT, default or 0)
    end

    function reader:ReadDouble(default)
        return _CLIENT_NETWORK(LuaNetworkOpcode.READ_DOUBLE, default or 0)
    end

    function reader:ReadString(default)
        return _CLIENT_NETWORK(LuaNetworkOpcode.READ_STRING, default or "")
    end

    function reader:Size()
        return _CLIENT_NETWORK(LuaNetworkOpcode.READ_SIZE)
    end

    return reader
end

-- Packet handler registry (opcode -> callbacks)
__callbacks = {}

--- Register a handler for a custom packet opcode
---@param opcode number Custom packet opcode to listen for
---@param callback function Function called with (reader) when packet is received
function OnCustomPacket(opcode, callback)
    if type(opcode) ~= "number" then
        error("OnCustomPacket: opcode must be a number")
    end
    if type(callback) ~= "function" then
        error("OnCustomPacket: callback must be a function")
    end
    
    if __callbacks[opcode] == nil then
        __callbacks[opcode] = {}
    end
    table.insert(__callbacks[opcode], callback)
end

--- Called by ClientExtensions.dll when a custom packet is received
--- This fires all registered callbacks for the opcode
---@param opcode number The custom packet opcode
function __FireCustomPacket(opcode)
    if __callbacks[opcode] == nil then
        return
    end
    
    for _, callback in pairs(__callbacks[opcode]) do
        local reader = __ReadCustomPacket()
        local success, err = pcall(callback, reader)
        if not success then
            print("|cFFFF0000CustomPackets Error:|r " .. tostring(err))
        end
        
        -- Reset for multiple consumers
        _CLIENT_NETWORK(LuaNetworkOpcode.RESET_CUSTOM_PACKET)
    end
end

print("|cFF00FF00CustomPackets|r Lua API loaded (TSWoW-compatible)")

`, timestamp,
		opts.ServerOpcode, opts.ClientOpcode,
		MaxFragmentSize, MinFragmentSize)

	return lua
}

// GenerateLuaAPIToAddonDir generates the Lua API to a WoW addon directory
func GenerateLuaAPIToAddonDir(wowPath string, addonName string) (string, error) {
	if addonName == "" {
		addonName = "CustomPackets"
	}

	addonDir := filepath.Join(wowPath, "Interface", "AddOns", addonName)
	luaPath := filepath.Join(addonDir, "CustomPackets.lua")

	opts := DefaultLuaGeneratorOptions()
	opts.OutputPath = luaPath

	if err := GenerateLuaAPI(opts); err != nil {
		return "", err
	}

	// Also generate a simple TOC file if it doesn't exist
	tocPath := filepath.Join(addonDir, addonName+".toc")
	if _, err := os.Stat(tocPath); os.IsNotExist(err) {
		tocContent := fmt.Sprintf(`## Interface: 30300
## Title: %s
## Notes: Custom packet API for server communication
## Author: Thorium

CustomPackets.lua
`, addonName)
		if err := os.WriteFile(tocPath, []byte(tocContent), 0644); err != nil {
			return "", fmt.Errorf("write TOC: %w", err)
		}
	}

	return addonDir, nil
}
